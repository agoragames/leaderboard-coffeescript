// Generated by CoffeeScript 1.8.0
(function() {
  var Leaderboard, TieRankingLeaderboard,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Leaderboard = require('./leaderboard');

  TieRankingLeaderboard = (function(_super) {

    /*
     * Default page size: 25
     */
    var DEFAULT_OPTIONS, DEFAULT_REDIS_OPTIONS;

    __extends(TieRankingLeaderboard, _super);

    TieRankingLeaderboard.DEFAULT_PAGE_SIZE = 25;


    /*
     * Default options when creating a leaderboard. Page size is 25 and reverse
     * is set to false, meaning various methods will return results in
     * highest-to-lowest order.
     */

    DEFAULT_OPTIONS = {
      'pageSize': TieRankingLeaderboard.DEFAULT_PAGE_SIZE,
      'reverse': false,
      'memberKey': 'member',
      'rankKey': 'rank',
      'scoreKey': 'score',
      'memberDataKey': 'member_data',
      'memberDataNamespace': 'member_data',
      'tiesNamespace': 'ties'
    };


    /*
     * Default Redis host: localhost
     */

    TieRankingLeaderboard.DEFAULT_REDIS_HOST = 'localhost';


    /*
     * Default Redis post: 6379
     */

    TieRankingLeaderboard.DEFAULT_REDIS_PORT = 6379;


    /*
     * Default Redis options when creating a connection to Redis. The
     * +DEFAULT_REDIS_HOST+ and +DEFAULT_REDIS_PORT+ will be passed.
     */

    DEFAULT_REDIS_OPTIONS = {
      'host': TieRankingLeaderboard.DEFAULT_REDIS_HOST,
      'port': TieRankingLeaderboard.DEFAULT_REDIS_PORT
    };

    function TieRankingLeaderboard(leaderboardName, options, redisOptions) {
      if (options == null) {
        options = DEFAULT_OPTIONS;
      }
      if (redisOptions == null) {
        redisOptions = DEFAULT_REDIS_OPTIONS;
      }
      TieRankingLeaderboard.__super__.constructor.apply(this, arguments);
      this.tiesNamespace = options['tiesNamespace'] || 'ties';
    }


    /*
     * Delete the named leaderboard.
     *
     * @param leaderboardName [String] Name of the leaderboard.
     * @param callback Optional callback for result of call.
     */

    TieRankingLeaderboard.prototype.deleteLeaderboardNamed = function(leaderboardName, callback) {
      var transaction;
      transaction = this.redisConnection.multi();
      transaction.del(leaderboardName);
      transaction.del(this.memberDataKey(leaderboardName));
      transaction.del(this.tiesLeaderboardKey(leaderboardName));
      return transaction.exec(function(err, reply) {
        if (callback) {
          return callback(reply);
        }
      });
    };


    /*
     * Change the score for a member in the named leaderboard by a delta which can be positive or negative.
     *
     * @param leaderboardName [String] Name of the leaderboard.
     * @param member [String] Member name.
     * @param delta [float] Score change.
     * @param callback Optional callback for result of call.
     */

    TieRankingLeaderboard.prototype.changeScoreForMemberIn = function(leaderboardName, member, delta, callback) {
      return this.scoreFor(member, (function(_this) {
        return function(score) {
          var newScore;
          newScore = score + delta;
          return _this.redisConnection.zrevrangebyscore(leaderboardName, score, score, function(err, totalMembers) {
            var transaction;
            transaction = _this.redisConnection.multi();
            transaction.zadd(leaderboardName, newScore, member);
            transaction.zadd(_this.tiesLeaderboardKey(leaderboardName), newScore, newScore);
            return transaction.exec(function(err, reply) {
              if (totalMembers.length === 1) {
                _this.redisConnection.zrem(_this.tiesLeaderboardKey(leaderboardName), score);
              }
              if (callback) {
                return callback(reply);
              }
            });
          });
        };
      })(this));
    };


    /*
     * Rank a member in the named leaderboard.
     *
     * @param leaderboardName [String] Name of the leaderboard.
     * @param member [String] Member name.
     * @param score [float] Member score.
     * @param memberData [String] Optional member data.
     * @param callback Optional callback for result of call.
     */

    TieRankingLeaderboard.prototype.rankMemberIn = function(leaderboardName, member, score, memberData, callback) {
      var transaction;
      if (memberData == null) {
        memberData = null;
      }
      transaction = this.redisConnection.multi();
      transaction.zadd(leaderboardName, score, member);
      transaction.zadd(this.tiesLeaderboardKey(leaderboardName), score, score);
      if (memberData != null) {
        transaction.hset(this.memberDataKey(leaderboardName), member, memberData);
      }
      return transaction.exec(function(err, reply) {
        if (callback) {
          return callback(reply);
        }
      });
    };


    /*
     * Rank a member across multiple leaderboards.
     *
     * @param leaderboards [Array] Leaderboard names.
     * @param member [String] Member name.
     * @param score [float] Member score.
     * @param member_data [String] Optional member data.
     */

    TieRankingLeaderboard.prototype.rankMemberAcross = function(leaderboardNames, member, score, memberData, callback) {
      var leaderboardName, transaction, _i, _len;
      if (memberData == null) {
        memberData = null;
      }
      transaction = this.redisConnection.multi();
      for (_i = 0, _len = leaderboardNames.length; _i < _len; _i++) {
        leaderboardName = leaderboardNames[_i];
        transaction.zadd(leaderboardName, score, member);
        transaction.zadd(this.tiesLeaderboardKey(leaderboardName), score, score);
        if (memberData != null) {
          transaction.hset(this.memberDataKey(leaderboardName), member, memberData);
        }
      }
      return transaction.exec(function(err, reply) {
        if (callback) {
          return callback(reply);
        }
      });
    };


    /*
     * Rank an array of members in the named leaderboard.
     *
     * @param leaderboardName [String] Name of the leaderboard.
     * @param membersAndScores [Array] Variable list of members and scores
     * @param callback Optional callback for result of call.
     */

    TieRankingLeaderboard.prototype.rankMembersIn = function(leaderboardName, membersAndScores, callback) {
      var index, slice, transaction, _i, _ref;
      transaction = this.redisConnection.multi();
      for (index = _i = 0, _ref = membersAndScores.length; _i < _ref; index = _i += 2) {
        slice = membersAndScores.slice(index, index + 2);
        transaction.zadd(leaderboardName, slice[1], slice[0]);
        transaction.zadd(this.tiesLeaderboardKey(leaderboardName), slice[0], slice[0]);
      }
      return transaction.exec(function(err, reply) {
        if (callback) {
          return callback(reply);
        }
      });
    };


    /*
     * Remove a member from the named leaderboard.
     *
     * @param leaderboardName [String] Name of the leaderboard.
     * @param member [String] Member name.
     * @param callback Optional callback for result of call.
     */

    TieRankingLeaderboard.prototype.removeMemberFrom = function(leaderboardName, member, callback) {
      return this.redisConnection.zscore(leaderboardName, member, (function(_this) {
        return function(err, score) {
          if (score != null) {
            if (_this.reverse) {
              return _this.redisConnection.zrangebyscore(leaderboardName, score, score, function(err, members) {
                var transaction;
                transaction = _this.redisConnection.multi();
                transaction.zrem(leaderboardName, member);
                if (members.length === 1) {
                  transaction.zrem(_this.tiesLeaderboardKey(leaderboardName), score);
                }
                transaction.hdel(_this.memberDataKey(leaderboardName), member);
                return transaction.exec(function(err, reply) {
                  if (callback) {
                    return callback(reply);
                  }
                });
              });
            } else {
              return _this.redisConnection.zrevrangebyscore(leaderboardName, score, score, function(err, members) {
                var transaction;
                transaction = _this.redisConnection.multi();
                transaction.zrem(leaderboardName, member);
                if (members.length === 1) {
                  transaction.zrem(_this.tiesLeaderboardKey(leaderboardName), score);
                }
                transaction.hdel(_this.memberDataKey(leaderboardName), member);
                return transaction.exec(function(err, reply) {
                  if (callback) {
                    return callback(reply);
                  }
                });
              });
            }
          } else {
            if (callback) {
              return callback(null);
            }
          }
        };
      })(this));
    };


    /*
     * Retrieve the rank for a member in the named leaderboard.
     *
     * @param leaderboardName [String] Name of the leaderboard.
     * @param member [String] Member name.
     * @param callback Callback for result of call.
     *
     * @return the rank for a member in the leaderboard.
     */

    TieRankingLeaderboard.prototype.rankForIn = function(leaderboardName, member, callback) {
      return this.redisConnection.zscore(leaderboardName, member, (function(_this) {
        return function(err, score) {
          if (_this.reverse) {
            return _this.redisConnection.zrank(_this.tiesLeaderboardKey(leaderboardName), score, function(err, rank) {
              return callback(rank + 1);
            });
          } else {
            return _this.redisConnection.zrevrank(_this.tiesLeaderboardKey(leaderboardName), score, function(err, rank) {
              return callback(rank + 1);
            });
          }
        };
      })(this));
    };


    /*
     * Retrieve the score and rank for a member in the named leaderboard.
     *
     * @param leaderboardName [String]Name of the leaderboard.
     * @param member [String] Member name.
     * @param callback Callback for result of call.
     *
     * @return the score and rank for a member in the named leaderboard as a Hash.
     */

    TieRankingLeaderboard.prototype.scoreAndRankForIn = function(leaderboardName, member, callback) {
      return this.redisConnection.zscore(leaderboardName, member, (function(_this) {
        return function(err, memberScore) {
          var transaction;
          transaction = _this.redisConnection.multi();
          transaction.zscore(leaderboardName, member);
          if (_this.reverse) {
            transaction.zrank(_this.tiesLeaderboardKey(leaderboardName), memberScore);
          } else {
            transaction.zrevrank(_this.tiesLeaderboardKey(leaderboardName), memberScore);
          }
          return transaction.exec(function(err, replies) {
            var scoreAndRankData;
            if (replies) {
              scoreAndRankData = {};
              if (replies[0] != null) {
                scoreAndRankData[_this.scoreKeyOption] = parseFloat(replies[0]);
              } else {
                scoreAndRankData[_this.scoreKeyOption] = null;
              }
              if (replies[1] != null) {
                scoreAndRankData[_this.rankKeyOption] = replies[1] + 1;
              } else {
                scoreAndRankData[_this.rankKeyOption] = null;
              }
              scoreAndRankData[_this.memberKeyOption] = member;
              return callback(scoreAndRankData);
            }
          });
        };
      })(this));
    };


    /*
     * Remove members from the named leaderboard in a given score range.
     *
     * @param leaderboardName [String] Name of the leaderboard.
     * @param minScore [float] Minimum score.
     * @param maxScore [float] Maximum score.
     * @param callback Optional callback for result of call.
     */

    TieRankingLeaderboard.prototype.removeMembersInScoreRangeIn = function(leaderboardName, minScore, maxScore, callback) {
      var transaction;
      transaction = this.redisConnection.multi();
      transaction.zremrangebyscore(leaderboardName, minScore, maxScore);
      transaction.zremrangebyscore(this.tiesLeaderboardKey(leaderboardName), minScore, maxScore);
      return transaction.exec(function(err, replies) {
        if (callback) {
          return callback(replies);
        }
      });
    };


    /*
     * Expire the given leaderboard in a set number of seconds. Do not use this with
     * leaderboards that utilize member data as there is no facility to cascade the
     * expiration out to the keys for the member data.
     *
     * @param leaderboardName [String] Name of the leaderboard.
     * @param seconds [int] Number of seconds after which the leaderboard will be expired.
     * @param callback Optional callback for result of call.
     */

    TieRankingLeaderboard.prototype.expireLeaderboardFor = function(leaderboardName, seconds, callback) {
      var transaction;
      transaction = this.redisConnection.multi();
      transaction.expire(leaderboardName, seconds);
      transaction.expire(this.tiesLeaderboardKey(leaderboardName), seconds);
      transaction.expire(this.memberDataKey(leaderboardName), seconds);
      return transaction.exec(function(err, replies) {
        if (callback) {
          return callback(replies);
        }
      });
    };


    /*
     * Expire the given leaderboard at a specific UNIX timestamp. Do not use this with
     * leaderboards that utilize member data as there is no facility to cascade the
     * expiration out to the keys for the member data.
     *
     * @param leaderboardName [String] Name of the leaderboard.
     * @param timestamp [int] UNIX timestamp at which the leaderboard will be expired.
     * @param callback Optional callback for result of call.
     */

    TieRankingLeaderboard.prototype.expireLeaderboardAtFor = function(leaderboardName, timestamp, callback) {
      var transaction;
      transaction = this.redisConnection.multi();
      transaction.expireat(leaderboardName, timestamp);
      transaction.expireat(this.tiesLeaderboardKey(leaderboardName), timestamp);
      transaction.expireat(this.memberDataKey(leaderboardName), timestamp);
      return transaction.exec(function(err, replies) {
        if (callback) {
          return callback(replies);
        }
      });
    };


    /*
     * Retrieve a page of leaders from the named leaderboard for a given list of members.
     *
     * @param leaderboardName [String] Name of the leaderboard.
     * @param members [Array] Member names.
     * @param options [Hash] Options to be used when retrieving the page from the named leaderboard.
     * @param callback Callback for result of call.
     *
     * @return a page of leaders from the named leaderboard for a given list of members.
     */

    TieRankingLeaderboard.prototype.rankedInListIn = function(leaderboardName, members, options, callback) {
      var member, ranksForMembers, transaction, _i, _len;
      if (options == null) {
        options = {};
      }
      if ((members == null) || members.length === 0) {
        return callback([]);
      }
      ranksForMembers = [];
      transaction = this.redisConnection.multi();
      if (!options['membersOnly']) {
        for (_i = 0, _len = members.length; _i < _len; _i++) {
          member = members[_i];
          if (this.reverse) {
            transaction.zrank(leaderboardName, member);
          } else {
            transaction.zrevrank(leaderboardName, member);
          }
          transaction.zscore(leaderboardName, member);
        }
      }
      return transaction.exec((function(_this) {
        return function(err, replies) {
          var index, _j, _len1, _results;
          _results = [];
          for (index = _j = 0, _len1 = members.length; _j < _len1; index = ++_j) {
            member = members[index];
            _results.push((function(member) {
              var data;
              data = {};
              data[_this.memberKeyOption] = member;
              if (!options['membersOnly']) {
                if (replies[index * 2 + 1]) {
                  data[_this.scoreKeyOption] = parseFloat(replies[index * 2 + 1]);
                } else {
                  data[_this.scoreKeyOption] = null;
                  data[_this.rankKeyOption] = null;
                }
              }
              if (options['withMemberData']) {
                return _this.memberDataForIn(leaderboardName, member, function(memberdata) {
                  data[_this.memberDataKeyOption] = memberdata;
                  if (_this.reverse) {
                    return _this.redisConnection.zrank(_this.tiesLeaderboardKey(leaderboardName), data[_this.scoreKeyOption], function(err, reply) {
                      data[_this.rankKeyOption] = reply + 1;
                      ranksForMembers.push(data);
                      if (ranksForMembers.length === members.length) {
                        switch (options['sortBy']) {
                          case 'rank':
                            ranksForMembers.sort(function(a, b) {
                              return a.rank > b.rank;
                            });
                            break;
                          case 'score':
                            ranksForMembers.sort(function(a, b) {
                              return a.score > b.score;
                            });
                        }
                        return callback(ranksForMembers);
                      }
                    });
                  } else {
                    return _this.redisConnection.zrevrank(_this.tiesLeaderboardKey(leaderboardName), data[_this.scoreKeyOption], function(err, reply) {
                      data[_this.rankKeyOption] = reply + 1;
                      ranksForMembers.push(data);
                      if (ranksForMembers.length === members.length) {
                        switch (options['sortBy']) {
                          case 'rank':
                            ranksForMembers.sort(function(a, b) {
                              return a.rank > b.rank;
                            });
                            break;
                          case 'score':
                            ranksForMembers.sort(function(a, b) {
                              return a.score > b.score;
                            });
                        }
                        return callback(ranksForMembers);
                      }
                    });
                  }
                });
              } else {
                if (_this.reverse) {
                  return _this.redisConnection.zrank(_this.tiesLeaderboardKey(leaderboardName), data[_this.scoreKeyOption], function(err, reply) {
                    data[_this.rankKeyOption] = reply + 1;
                    ranksForMembers.push(data);
                    if (ranksForMembers.length === members.length) {
                      switch (options['sortBy']) {
                        case 'rank':
                          ranksForMembers.sort(function(a, b) {
                            return a.rank > b.rank;
                          });
                          break;
                        case 'score':
                          ranksForMembers.sort(function(a, b) {
                            return a.score > b.score;
                          });
                      }
                      return callback(ranksForMembers);
                    }
                  });
                } else {
                  return _this.redisConnection.zrevrank(_this.tiesLeaderboardKey(leaderboardName), data[_this.scoreKeyOption], function(err, reply) {
                    data[_this.rankKeyOption] = reply + 1;
                    ranksForMembers.push(data);
                    if (ranksForMembers.length === members.length) {
                      switch (options['sortBy']) {
                        case 'rank':
                          ranksForMembers.sort(function(a, b) {
                            return a.rank > b.rank;
                          });
                          break;
                        case 'score':
                          ranksForMembers.sort(function(a, b) {
                            return a.score > b.score;
                          });
                      }
                      return callback(ranksForMembers);
                    }
                  });
                }
              }
            })(member));
          }
          return _results;
        };
      })(this));
    };

    TieRankingLeaderboard.prototype.tiesLeaderboardKey = function(leaderboardName) {
      return "" + leaderboardName + ":" + this.tiesNamespace;
    };

    return TieRankingLeaderboard;

  })(Leaderboard);

  module.exports = TieRankingLeaderboard;

}).call(this);
